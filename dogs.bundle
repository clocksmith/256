
üêï --- DOGS_START_FILE: public/components/4/1/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Storm Within: An LLM's Cognitive Battlefield</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg-calm: #e0f7fa;
            --bg-stormy: #011F4B;
            --orb-color: #4dd0e1;
            --orb-glow: #ffffff;
            --cloud-color: #b0bec5;
            --intrusive-color: #ff5252;
            --particle-color: #ffffff;
            --meter-bg: #455a64;
            --meter-fill-low: #66bb6a;
            --meter-fill-med: #fdd835;
            --meter-fill-high: #ef5350;
            --text-color-dark: #e0e0e0;
            --text-color-light: #212121;
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            transition: background-color 1s ease;
        }
        .light-mode {
            --bg-calm: #e0f7fa;
            --bg-stormy: #90a4ae;
            --orb-color: #00838f;
            --orb-glow: #000000;
            --cloud-color: #78909c;
            --intrusive-color: #d32f2f;
            --particle-color: #424242;
        }
        #simulation-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-calm);
            transition: background-color 1s ease;
        }
        #focus-orb {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80px;
            height: 80px;
            background-color: var(--orb-color);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(1);
            box-shadow: 0 0 15px 5px var(--orb-color), 0 0 30px 10px rgba(255,255,255,0.3);
            animation: pulse 4s infinite ease-in-out;
            transition: transform 0.5s ease, box-shadow 0.5s ease, background-color 0.5s ease, width 0.5s ease, height 0.5s ease;
        }
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        .cloud {
            position: absolute;
            background-color: var(--cloud-color);
            border-radius: 50%;
            opacity: 0;
            animation: fadeInAndDrift 20s linear infinite;
            filter: blur(10px);
        }
        .intrusive-thought {
            position: absolute;
            color: var(--intrusive-color);
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            animation: intrusive-pop 15s linear infinite;
            text-shadow: 0 0 8px var(--intrusive-color);
            cursor: pointer;
            user-select: none;
        }
        @keyframes fadeInAndDrift {
            0% { opacity: 0; transform: translateX(-100px); }
            20% { opacity: 0.3; }
            80% { opacity: 0.3; }
            100% { opacity: 0; transform: translateX(calc(100vw + 100px)); }
        }
        @keyframes intrusive-pop {
            0% { transform: scale(0.5); opacity: 0; }
            10% { transform: scale(1.2); opacity: 0.9; }
            90% { transform: scale(1); opacity: 0.9; }
            100% { transform: scale(0.5); opacity: 0; }
        }
        .ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
        }
        .meter {
            width: 250px;
            height: 20px;
            background-color: var(--meter-bg);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .meter-bar {
            width: 0%;
            height: 100%;
            background-color: var(--meter-fill-low);
            transition: width 0.5s ease, background-color 0.5s ease;
            border-radius: 10px 0 0 10px;
        }
        label, button {
            color: var(--text-color-dark);
            background-color: transparent;
            border: 1px solid var(--text-color-dark);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        body.light-mode label, body.light-mode button {
            color: var(--text-color-light);
            border-color: var(--text-color-light);
        }
    </style>
</head>
<body>
    <div id="simulation-container">
        <div id="focus-orb"></div>
    </div>
    <div class="ui-container">
        <label for="complexity-slider">Context Complexity</label>
        <input type="range" id="complexity-slider" min="0" max="100" value="0" style="width: 250px;">
        <div class="meter">
            <div id="load-meter-bar" class="meter-bar"></div>
        </div>
        <button id="clarity-button">Moment of Clarity</button>
    </div>

    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');

        const container = document.getElementById('simulation-container');
        const orb = document.getElementById('focus-orb');
        const slider = document.getElementById('complexity-slider');
        const loadMeterBar = document.getElementById('load-meter-bar');
        const clarityButton = document.getElementById('clarity-button');

        const symbols = ['?', '!', '¬ß', '#', '@', '...', 'üî•'];

        function createCloud() {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            cloud.style.width = `${Math.random() * 150 + 50}px`;
            cloud.style.height = `${Math.random() * 80 + 40}px`;
            cloud.style.top = `${Math.random() * 100}vh`;
            cloud.style.animationDuration = `${Math.random() * 20 + 15}s`;
            cloud.style.animationDelay = `${Math.random() * 5}s`;
            return cloud;
        }

        function createIntrusiveThought() {
            const thought = document.createElement('div');
            thought.className = 'intrusive-thought';
            thought.textContent = symbols[Math.floor(Math.random() * symbols.length)];
            thought.style.top = `${Math.random() * 90}vh`;
            thought.style.left = `${Math.random() * 90}vw`;
            thought.style.animationDuration = `${Math.random() * 10 + 8}s`;
            thought.style.animationDelay = `${Math.random() * 3}s`;
            thought.addEventListener('click', () => {
                thought.style.opacity = '0';
                const currentLoad = parseFloat(loadMeterBar.style.width) || 0;
                loadMeterBar.style.width = Math.min(100, currentLoad + 2) + '%';
                setTimeout(() => thought.remove(), 500);
            });
            return thought;
        }

        slider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            
            // Update Cognitive Load Meter
            loadMeterBar.style.width = value + '%';
            if (value > 75) {
                loadMeterBar.style.backgroundColor = 'var(--meter-fill-high)';
            } else if (value > 40) {
                loadMeterBar.style.backgroundColor = 'var(--meter-fill-med)';
            } else {
                loadMeterBar.style.backgroundColor = 'var(--meter-fill-low)';
            }
            
            // Update Orb
            const scale = 1 - (value / 200);
            orb.style.transform = `translate(-50%, -50%) scale(${scale})`;
            const orbOpacity = 1 - (value / 150);
            orb.style.boxShadow = `0 0 ${15 * orbOpacity}px 5px var(--orb-color), 0 0 ${30 * orbOpacity}px 10px rgba(255,255,255,0.3)`;
            orb.style.animationPlayState = value > 50 ? 'paused' : 'running';

            // Update Background Storm
            container.style.backgroundColor = `color-mix(in srgb, var(--bg-calm) ${100-value}%, var(--bg-stormy))`;

            // Add/Remove elements
            const existingClouds = document.querySelectorAll('.cloud').length;
            const targetClouds = Math.floor(value / 10);
            if (existingClouds < targetClouds) {
                for (let i = 0; i < targetClouds - existingClouds; i++) {
                    container.appendChild(createCloud());
                }
            }
            
            const existingThoughts = document.querySelectorAll('.intrusive-thought').length;
            const targetThoughts = Math.floor(value / 5);
            if (existingThoughts < targetThoughts) {
                 for (let i = 0; i < targetThoughts - existingThoughts; i++) {
                    container.appendChild(createIntrusiveThought());
                }
            }
        });
        
        clarityButton.addEventListener('click', () => {
             container.style.transition = 'background-color 0.2s ease';
             container.style.backgroundColor = 'var(--bg-calm)';
             document.querySelectorAll('.intrusive-thought, .cloud').forEach(el => el.style.opacity = '0');
             orb.style.transform = 'translate(-50%, -50%) scale(1.2)';
             orb.style.boxShadow = `0 0 25px 10px var(--orb-color), 0 0 50px 20px rgba(255,255,255,0.5)`;

             setTimeout(() => {
                 slider.value = 10;
                 slider.dispatchEvent(new Event('input'));
                 container.style.transition = 'background-color 1s ease';
             }, 1000);
             setTimeout(() => {
                 document.querySelectorAll('.intrusive-thought, .cloud').forEach(el => el.remove());
             }, 500);
        });
    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/1/index.html ---
üêï --- DOGS_START_FILE: public/components/4/2/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Expanding Room of Thoughts: Mental Clutter Accumulation</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg-color: #f5f5f5;
            --text-color: #333;
            --room-border: #9e9e9e;
            --relevant-bg: #4caf50;
            --relevant-text: #ffffff;
            --clutter-bg: #bdbdbd;
            --clutter-text: #616161;
            --spotlight-color: rgba(255, 255, 0, 0.25);
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .light-mode { /* Same as default */ }
        .dark-mode {
            --bg-color: #212121;
            --text-color: #e0e0e0;
            --room-border: #616161;
            --relevant-bg: #81c784;
            --relevant-text: #000000;
            --clutter-bg: #424242;
            --clutter-text: #9e9e9e;
            --spotlight-color: rgba(255, 255, 100, 0.15);
        }
        #ui-controls {
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            background: rgba(0,0,0,0.05);
        }
        .dark-mode #ui-controls {
             background: rgba(255,255,255,0.05);
        }
        #room-container {
            flex-grow: 1;
            width: 50%;
            height: 50%;
            border: 2px dashed var(--room-border);
            position: relative;
            transition: all 0.5s ease-in-out;
            margin-top: 20px;
        }
        .thought-object {
            position: absolute;
            padding: 5px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            transition: transform 0.3s ease, opacity 0.3s ease;
            user-select: none;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            white-space: nowrap;
        }
        .relevant-thought {
            background-color: var(--relevant-bg);
            color: var(--relevant-text);
            z-index: 5;
            border: 1px solid #fff;
        }
        .clutter-thought {
            background-color: var(--clutter-bg);
            color: var(--clutter-text);
            z-index: 4;
        }
        #focus-spotlight {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background-color: var(--spotlight-color);
            pointer-events: none;
            z-index: 10;
            transition: all 0.1s linear;
            box-shadow: 0 0 15px var(--spotlight-color);
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="ui-controls">
        <label for="context-slider">Increase Context Window / Add Information</label>
        <input type="range" id="context-slider" min="0" max="100" value="0" style="width: 80%;">
        <p>Cognitive Effort to Find Relevant Thoughts: <span id="effort-counter">0</span></p>
    </div>
    <div id="room-container">
        <div id="focus-spotlight"></div>
    </div>

    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');

        const slider = document.getElementById('context-slider');
        const room = document.getElementById('room-container');
        const effortCounter = document.getElementById('effort-counter');
        const spotlight = document.getElementById('focus-spotlight');

        let effort = 0;
        const relevantThoughts = [];

        function createThought(isRelevant, text) {
            const thought = document.createElement('div');
            thought.className = isRelevant ? 'thought-object relevant-thought' : 'thought-object clutter-thought';
            thought.textContent = text;
            
            thought.style.left = `${Math.random() * 85}%`;
            thought.style.top = `${Math.random() * 85}%`;

            if (!isRelevant) {
                thought.addEventListener('click', () => {
                    effort += 10;
                    effortCounter.textContent = effort;
                    thought.style.opacity = '0.2';
                    setTimeout(() => thought.style.opacity = '1', 500);
                });
            }
            return thought;
        }

        function init() {
            const initialRelevant = ['Key Fact 1', 'Core Query', 'Main Idea'];
            initialRelevant.forEach(text => {
                const thought = createThought(true, text);
                relevantThoughts.push(thought);
                room.appendChild(thought);
            });
        }

        slider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            const scale = 50 + (value / 2);
            room.style.width = `${scale}%`;
            room.style.height = `${scale}%`;
            
            effort = value * 5;
            effortCounter.textContent = effort;

            const existingClutter = document.querySelectorAll('.clutter-thought').length;
            const targetClutter = Math.floor(value / 2);

            if(existingClutter < targetClutter) {
                for (let i = 0; i < targetClutter - existingClutter; i++) {
                    room.appendChild(createThought(false, `Token #${Math.floor(Math.random()*1000)}`));
                }
            }
        });

        room.addEventListener('mousemove', (e) => {
            const rect = room.getBoundingClientRect();
            spotlight.style.left = `${e.clientX - rect.left}px`;
            spotlight.style.top = `${e.clientY - rect.top}px`;
        });
        
        init();
    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/2/index.html ---
üêï --- DOGS_START_FILE: public/components/4/3/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Mind's Interconnecting Threads: A Self-Attention Simulation</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg: #1a1a1a;
            --text-color: #f0f0f0;
            --node-bg: #333;
            --node-border: #555;
            --node-active-border: #4dd0e1;
            --node-distractor-border: #ff7043;
            --q-strand: #4fc3f7;
            --k-strand: #81c784;
            --v-strand: #e57373;
        }
        body.light-mode {
            --bg: #fafafa;
            --text-color: #212121;
            --node-bg: #e0e0e0;
            --node-border: #bdbdbd;
            --node-active-border: #0097a7;
            --node-distractor-border: #e64a19;
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: var(--bg);
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        #canvas-container {
            position: relative;
            width: 95vmin;
            height: 95vmin;
        }
        .thought-node {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: var(--node-bg);
            border: 2px solid var(--node-border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 5;
        }
        .thought-node.active {
            border-color: var(--node-active-border);
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--node-active-border);
        }
        .thought-node.distractor {
            border-color: var(--node-distractor-border);
        }
        .strand {
            position: absolute;
            height: 2px;
            transform-origin: 0 50%;
            z-index: 1;
            opacity: 0;
            transition: all 0.5s ease-out;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        button {
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid var(--text-color);
            background: var(--bg);
            color: var(--text-color);
            cursor: pointer;
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="controls">
        <button id="next-step-btn">Next Step</button>
        <button id="reset-btn">Reset</button>
    </div>
    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');

        const container = document.getElementById('canvas-container');
        const nextBtn = document.getElementById('next-step-btn');
        const resetBtn = document.getElementById('reset-btn');

        const nodesData = [
            { text: 'The cat', isDistractor: false }, { text: 'sat', isDistractor: false },
            { text: 'on the', isDistractor: false }, { text: 'mat', isDistractor: false },
            { text: 'because', isDistractor: false }, { text: 'it', isDistractor: true },
            { text: 'was', isDistractor: false }, { text: 'warm', isDistractor: false }
        ];
        let nodes = [];
        let strands = [];
        let state = -1;
        const activeNodeIndex = 0; // The node we are calculating attention FOR

        function createNodes() {
            container.innerHTML = '';
            nodes = [];
            const radius = container.offsetWidth / 2 - 40;
            const centerX = container.offsetWidth / 2;
            const centerY = container.offsetHeight / 2;

            nodesData.forEach((data, i) => {
                const angle = (i / nodesData.length) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                const nodeEl = document.createElement('div');
                nodeEl.className = 'thought-node' + (data.isDistractor ? ' distractor' : '');
                nodeEl.textContent = data.text;
                nodeEl.style.left = `${x - 30}px`;
                nodeEl.style.top = `${y - 30}px`;
                container.appendChild(nodeEl);
                nodes.push({ el: nodeEl, x, y, data });
            });
        }

        function createStrand(fromNode, toNode, color) {
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            const strandEl = document.createElement('div');
            strandEl.className = 'strand';
            strandEl.style.backgroundColor = color;
            strandEl.style.width = `${distance}px`;
            strandEl.style.left = `${fromNode.x}px`;
            strandEl.style.top = `${fromNode.y}px`;
            strandEl.style.transform = `rotate(${angle}deg)`;
            container.appendChild(strandEl);
            return strandEl;
        }

        function runStep() {
            state = (state + 1) % 5;
            strands.forEach(s => s.remove());
            strands = [];
            nodes.forEach(n => n.el.classList.remove('active'));

            const activeNode = nodes[activeNodeIndex];
            activeNode.el.classList.add('active');

            switch (state) {
                case 0: // Show Query Strands
                    nodes.forEach(n => {
                        const strand = createStrand(activeNode, n, 'var(--q-strand)');
                        strands.push(strand);
                        setTimeout(() => strand.style.opacity = '0.5', 50);
                    });
                    break;
                case 1: // Show Key Strands & Resonance
                    nodes.forEach(n => {
                        const strand = createStrand(activeNode, n, 'var(--k-strand)');
                        strands.push(strand);
                        setTimeout(() => strand.style.opacity = '0.5', 50);
                    });
                    break;
                case 2: // Show Attention Scores (Softmax)
                    nodes.forEach((n, i) => {
                        const isRelevant = i === 3; // "mat" is most relevant to "it"
                        const isSelf = i === activeNodeIndex;
                        const opacity = isRelevant ? 1.0 : (isSelf ? 0.4 : 0.1);
                        const color = isRelevant ? 'var(--node-active-border)' : 'var(--k-strand)';
                        
                        const strand = createStrand(activeNode, n, color);
                        strands.push(strand);
                        setTimeout(() => {
                           strand.style.opacity = opacity;
                           strand.style.height = `${1 + opacity * 3}px`;
                        }, 50);
                    });
                    break;
                case 3: // Show Value Aggregation
                    nodes.forEach((n, i) => {
                         const isRelevant = i === 3;
                         if (isRelevant) {
                            const strand = createStrand(n, activeNode, 'var(--v-strand)');
                            strands.push(strand);
                            setTimeout(() => { strand.style.opacity = '0.8'; strand.style.height = '3px'}, 50);
                         }
                    });
                    break;
                case 4: // Final refined state
                    activeNode.el.style.backgroundColor = '#66bb6a'; // Show a 'refined' state
                    break;
            }
        }
        
        function reset() {
            state = -1;
            strands.forEach(s => s.remove());
            strands = [];
            nodes.forEach(n => {
                n.el.classList.remove('active');
                n.el.style.backgroundColor = '';
            });
        }

        nextBtn.addEventListener('click', runStep);
        resetBtn.addEventListener('click', reset);
        
        createNodes();
    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/3/index.html ---
üêï --- DOGS_START_FILE: public/components/4/4/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Tempest's Toll: Processing Speed vs. Cognitive Overload</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg-color: #1e1e1e;
            --text-color: #d4d4d4;
            --grid-color: #444;
            --latency-color: #ff6b6b;
            --throughput-color: #4db6ac;
            --label-color: #888;
        }
        body.light-mode {
            --bg-color: #ffffff;
            --text-color: #333;
            --grid-color: #e0e0e0;
            --latency-color: #d32f2f;
            --throughput-color: #00796b;
            --label-color: #666;
        }
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        #chart-container {
            width: 100%;
            height: 70%;
            position: relative;
        }
        #chart-canvas {
            width: 100%;
            height: 100%;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        label {
            margin-right: 10px;
        }
        input[type=range] {
            width: 300px;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="chart-container">
        <canvas id="chart-canvas"></canvas>
    </div>
    <div class="controls">
        <label for="context-slider">Context Length / Active Thoughts</label>
        <input type="range" id="context-slider" min="0" max="100" value="10">
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--latency-color);"></div>
                <span>Mental Lag (Latency)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--throughput-color);"></div>
                <span>Clarity (Throughput)</span>
            </div>
        </div>
    </div>
    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');

        const canvas = document.getElementById('chart-canvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('context-slider');

        let w, h, padding = 40;
        
        // Data points (x: slider value, y: normalized value 0-1)
        const latencyData = [{x:0, y:0.05}, {x:20, y:0.1}, {x:50, y:0.3}, {x:80, y:0.7}, {x:100, y:1}];
        const throughputData = [{x:0, y:0.95}, {x:20, y:0.8}, {x:50, y:0.5}, {x:80, y:0.2}, {x:100, y:0.05}];

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            w = canvas.clientWidth;
            h = canvas.clientHeight;
            drawChart();
        }

        function interpolate(data, x) {
            for (let i = 0; i < data.length - 1; i++) {
                if (x >= data[i].x && x <= data[i+1].x) {
                    const t = (x - data[i].x) / (data[i+1].x - data[i].x);
                    return data[i].y + t * (data[i+1].y - data[i].y);
                }
            }
            return data[data.length-1].y;
        }

        function drawChart() {
            ctx.clearRect(0, 0, w, h);
            
            const styles = getComputedStyle(document.body);
            const gridColor = styles.getPropertyValue('--grid-color');
            const textColor = styles.getPropertyValue('--text-color');
            const latencyColor = styles.getPropertyValue('--latency-color');
            const throughputColor = styles.getPropertyValue('--throughput-color');
            
            ctx.strokeStyle = gridColor;
            ctx.fillStyle = textColor;
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';

            // Y axis
            for(let i=0; i<=10; i++) {
                const y = h - padding - (i/10) * (h - 2*padding);
                ctx.fillText(`${i*10}%`, padding - 10, y);
                ctx.beginPath();
                ctx.moveTo(padding - 5, y);
                ctx.lineTo(w - padding, y);
                ctx.stroke();
            }
            
            // X axis
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for(let i=0; i<=10; i++) {
                const x = padding + (i/10) * (w - 2*padding);
                ctx.fillText(`${i*100}k`, x, h - padding + 10);
            }

            const value = slider.value;
            drawPath(latencyData, latencyColor, value);
            drawPath(throughputData, throughputColor, value);
        }

        function drawPath(data, color, currentValue) {
             ctx.beginPath();
             ctx.strokeStyle = color;
             ctx.lineWidth = 2;
             
             let currentPoint = {x: 0, y: 0};

             for(let x=0; x<=100; x++) {
                 const normX = x/100;
                 const normY = interpolate(data, x);
                 const plotX = padding + normX * (w - 2 * padding);
                 const plotY = h - padding - normY * (h - 2 * padding);
                 
                 if (x === 0) {
                     ctx.moveTo(plotX, plotY);
                 } else {
                     ctx.lineTo(plotX, plotY);
                 }
                 
                 if (x === parseInt(currentValue)) {
                     currentPoint = {x: plotX, y: plotY};
                 }
             }
             ctx.stroke();
             
             // Draw circle at current value
             ctx.beginPath();
             ctx.fillStyle = color;
             ctx.arc(currentPoint.x, currentPoint.y, 5, 0, 2 * Math.PI);
             ctx.fill();
        }

        slider.addEventListener('input', drawChart);
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/4/index.html ---
üêï --- DOGS_START_FILE: public/components/4/5/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapping the Mental Maelstrom: Defining Attention Thrashing</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg: #111827;
            --text-color: #e5e7eb;
            --node-bg: #374151;
            --node-border: #4b5563;
            --central-node-bg: #be123c;
            --cause-node-bg: #1d4ed8;
            --symptom-node-bg: #b45309;
            --line-color: #6b7280;
            --highlight-color: #f59e0b;
        }
        body.light-mode {
            --bg: #f9fafb;
            --text-color: #111827;
            --node-bg: #e5e7eb;
            --node-border: #d1d5db;
            --central-node-bg: #dc2626;
            --cause-node-bg: #2563eb;
            --symptom-node-bg: #d97706;
            --line-color: #9ca3af;
        }
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--bg);
            color: var(--text-color);
            margin: 0;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        #flowchart-container {
            position: relative;
            width: 95vmin;
            height: 95vmin;
        }
        .node {
            position: absolute;
            padding: 8px 12px;
            border: 1px solid var(--node-border);
            border-radius: 8px;
            background-color: var(--node-bg);
            font-size: clamp(8px, 1.5vmin, 12px);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            z-index: 10;
        }
        .node:hover {
            transform: scale(1.05);
            border-color: var(--highlight-color);
        }
        #central-node { background-color: var(--central-node-bg); font-weight: bold; font-size: 1.2em; }
        .cause-node { background-color: var(--cause-node-bg); }
        .symptom-node { background-color: var(--symptom-node-bg); }
        .line {
            position: absolute;
            background-color: var(--line-color);
            z-index: 1;
            transform-origin: 0 0;
            transition: background-color 0.2s ease;
        }
        .line.highlighted {
            background-color: var(--highlight-color);
            z-index: 5;
        }
        .tooltip {
            position: absolute;
            background-color: #000;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        body.light-mode .tooltip { background-color: #fff; color: #000; border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div id="flowchart-container"></div>
    <div class="tooltip" id="tooltip"></div>
    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');

        const container = document.getElementById('flowchart-container');
        const tooltip = document.getElementById('tooltip');
        
        const nodes = {
            central: { id: 'central-node', text: 'Attention Thrashing (The Inner Tempest)', x: 50, y: 50, tooltip: "The core state of inefficient, unstable, and misdirected LLM focus under high context load." },
            cause1: { id: 'cause1', text: 'Overwhelming Context', class: 'cause-node', x: 20, y: 20, tooltip: "Excessive context window size and a high volume of irrelevant tokens." },
            cause2: { id: 'cause2', text: 'Mechanism Limits', class: 'cause-node', x: 80, y: 20, tooltip: "Inherent O(N¬≤) complexity and KV cache memory pressure." },
            symptom1: { id: 'symptom1', text: 'High Latency / Low Throughput', class: 'symptom-node', x: 10, y: 80, tooltip: "Slower response times and reduced processing speed." },
            symptom2: { id: 'symptom2', text: 'Accuracy Degradation', class: 'symptom-node', x: 40, y: 80, tooltip: "'Lost in the Middle' errors and poor 'Needle-in-a-Haystack' performance." },
            symptom3: { id: 'symptom3', text: 'Ineffective Focus', class: 'symptom-node', x: 70, y: 80, tooltip: "Attention gets 'stuck' on irrelevant tokens (Attention Sinks)." },
             symptom4: { id: 'symptom4', text: 'Resource Waste', class: 'symptom-node', x: 90, y: 50, tooltip: "Disproportionate FLOPs and memory bandwidth spent on non-productive processing." }
        };

        const connections = [
            ['cause1', 'central'], ['cause2', 'central'],
            ['central', 'symptom1'], ['central', 'symptom2'],
            ['central', 'symptom3'], ['central', 'symptom4']
        ];

        let lineElements = {};

        function createNode(nodeData) {
            const nodeEl = document.createElement('div');
            nodeEl.id = nodeData.id;
            nodeEl.className = 'node ' + (nodeData.class || '');
            nodeEl.textContent = nodeData.text;
            nodeEl.style.left = `calc(${nodeData.x}% - ${nodeEl.offsetWidth / 2}px)`;
            nodeEl.style.top = `calc(${nodeData.y}% - ${nodeEl.offsetHeight / 2}px)`;
            nodeEl.dataset.tooltip = nodeData.tooltip;
            container.appendChild(nodeEl);
            return nodeEl;
        }
        
        function createLine(p1, p2, id) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            const lineEl = document.createElement('div');
            lineEl.className = 'line';
            lineEl.id = id;
            lineEl.style.width = `${distance}px`;
            lineEl.style.height = '2px';
            lineEl.style.left = `${p1.x}px`;
            lineEl.style.top = `${p1.y}px`;
            lineEl.style.transform = `rotate(${angle}deg)`;
            container.appendChild(lineEl);
            return lineEl;
        }

        function drawFlowchart() {
            Object.values(nodes).forEach(n => createNode(n));
            
            connections.forEach(([fromId, toId]) => {
                const fromNode = document.getElementById(nodes[fromId].id);
                const toNode = document.getElementById(nodes[toId].id);

                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                
                const p1 = { x: fromRect.left + fromRect.width / 2 - containerRect.left, y: fromRect.top + fromRect.height / 2 - containerRect.top };
                const p2 = { x: toRect.left + toRect.width / 2 - containerRect.left, y: toRect.top + toRect.height / 2 - containerRect.top };

                const lineId = `line-${fromId}-${toId}`;
                lineElements[lineId] = createLine(p1, p2, lineId);
            });
        }
        
        document.querySelectorAll('.node').forEach(node => {
            node.addEventListener('mouseover', (e) => {
                tooltip.textContent = e.target.dataset.tooltip;
                tooltip.style.opacity = '1';
            });
            node.addEventListener('mousemove', (e) => {
                tooltip.style.left = `${e.clientX + 15}px`;
                tooltip.style.top = `${e.clientY + 15}px`;
            });
            node.addEventListener('mouseout', () => {
                tooltip.style.opacity = '0';
            });
             node.addEventListener('click', (e) => {
                 const clickedId = e.target.id.replace('-node','');
                 
                 Object.values(lineElements).forEach(line => line.classList.remove('highlighted'));

                 connections.forEach(([from, to]) => {
                     if(from === clickedId || to === clickedId){
                         const line = document.getElementById(`line-${from}-${to}`);
                         if(line) line.classList.add('highlighted');
                     }
                 });
             });
        });
        
        drawFlowchart(); // Initial draw
        // Redraw on resize to adjust positions
        new ResizeObserver(drawFlowchart).observe(container);

    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/5/index.html ---
üêï --- DOGS_START_FILE: public/components/4/6/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conjuring the Cognitive Fog: Simulating Inefficient Attention</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg: #1f2937;
            --text-color: #d1d5db;
            --controls-bg: #374151;
            --context-bg: #4b5563;
            --target-bg: #111827;
            --keyword-color: #facc15;
            --correct-color: #4ade80;
            --incorrect-color: #f87171;
        }
        body.light-mode {
            --bg: #f3f4f6;
            --text-color: #1f2937;
            --controls-bg: #e5e7eb;
            --context-bg: #d1d5db;
            --target-bg: #ffffff;
            --keyword-color: #b45309;
            --correct-color: #16a34a;
            --incorrect-color: #dc2626;
        }
        body {
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .controls {
            padding: 10px;
            background-color: var(--controls-bg);
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 10;
        }
        .controls label { margin: 0 10px; }
        .task-container {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
        }
        .target-sentence {
            background: var(--target-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 1.1em;
            line-height: 1.6;
        }
        .target-sentence strong { color: var(--keyword-color); }
        .context-paragraph {
            background: var(--context-bg);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.8;
            font-size: 1em;
            position: relative;
            overflow: hidden;
        }
        .context-paragraph span {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .context-paragraph span:hover { background: rgba(255,255,255,0.1); }
        .dark-mode .context-paragraph span:hover { background: rgba(0,0,0,0.1); }
        
        /* Attention Modes */
        .uniform-fog span { filter: blur(1px); opacity: 0.7; }
        .random-scatter span.flash { animation: flash 1s infinite alternate; }
        @keyframes flash { from { background-color: rgba(255, 255, 0, 0.3); } to { background-color: transparent; } }
        .tunnel-vision { overflow: hidden; }
        #tunnel-spotlight { position: absolute; background: radial-gradient(circle, transparent 50px, var(--context-bg) 150px); pointer-events: none; }
        .attention-sink { font-weight: bold; color: var(--incorrect-color); animation: pulse-sink 2s infinite; }
        @keyframes pulse-sink { 50% { transform: scale(1.2); } }
    </style>
</head>
<body>
    <div class="controls">
        <label><input type="radio" name="mode" value="focused" checked> Focused Mind</label>
        <label><input type="radio" name="mode" value="uniform"> Brain Fog</label>
        <label><input type="radio" name="mode" value="random"> Scattered Thoughts</label>
        <label><input type="radio" name="mode" value="sink"> Attention Sink</label>
    </div>
    <div class="task-container">
        <div class="target-sentence">
            Find the keywords: The <strong>blue</strong> fox quickly found the <strong>hidden</strong> message near the <strong>ancient</strong> tree.
        </div>
        <div class="context-paragraph" id="context"></div>
        <p>Score: <span id="score">0</span> | Time: <span id="timer">0</span>s</p>
    </div>

    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');

        const contextEl = document.getElementById('context');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const modes = document.querySelectorAll('input[name="mode"]');
        
        const keywords = ['blue', 'hidden', 'ancient'];
        let score = 0;
        let foundKeywords = [];
        let timerInterval;

        const clutter = "the a of to and in that is it for on with as I his he but at by from they have or she an which you one said were all when there would so up out if about who get which go me when make can like time no just him know take people into year your good some could them see other than then now look only come its over think also back after use two how our work first well way even new want because any these give day most us".split(" ");
        
        function generateContext() {
            let words = [];
            for (let i=0; i<150; i++) {
                words.push(clutter[Math.floor(Math.random() * clutter.length)]);
            }
            keywords.forEach(kw => {
                words.splice(Math.floor(Math.random() * words.length), 0, kw);
            });
            
            contextEl.innerHTML = words.map(word => `<span data-word="${word}">${word} </span>`).join('');
            
            contextEl.querySelectorAll('span').forEach(span => {
                span.addEventListener('click', onWordClick);
            });
        }
        
        function onWordClick(e) {
            const word = e.target.dataset.word;
            if (keywords.includes(word) && !foundKeywords.includes(word)) {
                score += 10;
                foundKeywords.push(word);
                e.target.style.backgroundColor = 'var(--correct-color)';
                e.target.style.pointerEvents = 'none';
            } else if (!keywords.includes(word)) {
                score -= 1;
                e.target.style.backgroundColor = 'var(--incorrect-color)';
                setTimeout(() => e.target.style.backgroundColor = '', 500);
            }
            scoreEl.textContent = score;
        }

        let scatterInterval;
        function applyMode(mode) {
            contextEl.className = 'context-paragraph'; // Reset
            clearInterval(scatterInterval);

            if (mode === 'uniform') {
                contextEl.classList.add('uniform-fog');
            } else if (mode === 'random') {
                contextEl.classList.add('random-scatter');
                const spans = contextEl.querySelectorAll('span');
                scatterInterval = setInterval(() => {
                    spans.forEach(s => s.classList.remove('flash'));
                    const randSpan = spans[Math.floor(Math.random() * spans.length)];
                    randSpan.classList.add('flash');
                }, 300);
            } else if (mode === 'sink') {
                const spans = contextEl.querySelectorAll('span');
                for(let i = 0; i < 3; i++) {
                    let randSpan;
                    do {
                       randSpan = spans[Math.floor(Math.random() * spans.length)];
                    } while(keywords.includes(randSpan.dataset.word));
                    randSpan.classList.add('attention-sink');
                }
            }
        }
        
        modes.forEach(radio => {
            radio.addEventListener('change', () => applyMode(radio.value));
        });

        function startTimer() {
            let seconds = 0;
            timerInterval = setInterval(() => {
                seconds++;
                timerEl.textContent = `${seconds}s`;
            }, 1000);
        }

        generateContext();
        startTimer();

    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/6/index.html ---
üêï --- DOGS_START_FILE: public/components/4/7/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shelter from the Storm: Strategies for a Focused AI Mind</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg: #1e293b;
            --text-color: #cbd5e1;
            --card-bg: #334155;
            --card-border: #475569;
            --accent-color: #38bdf8;
            --title-color: #f8fafc;
        }
        body.light-mode {
            --bg: #f1f5f9;
            --text-color: #334155;
            --card-bg: #ffffff;
            --card-border: #e2e8f0;
            --accent-color: #0284c7;
            --title-color: #0f172a;
        }
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text-color);
            transition: all 0.3s ease;
            height: 100vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        #toolkit-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .strategy-card {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .strategy-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .card-header {
            text-align: center;
            margin-bottom: 15px;
        }
        .card-title {
            font-size: 1.25em;
            font-weight: bold;
            color: var(--title-color);
        }
        .card-analogy {
            font-style: italic;
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        .card-visualization {
            flex-grow: 1;
            border: 1px solid var(--card-border);
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 120px;
            padding: 10px;
            background: var(--bg);
        }
        .card-explanation {
            font-size: 0.95em;
            line-height: 1.6;
        }
        /* Visualizations */
        .viz-dots { display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-color); opacity: 0.3; transition: all 0.3s; }
        .strategy-card.active .dot.relevant { background: var(--accent-color); opacity: 1; transform: scale(1.5); }

        .viz-line { width: 100%; height: 2px; background: var(--text-color); position: relative; }
        .viz-line::after { content: ''; position: absolute; width: 10px; height: 10px; border-radius: 50%; background: var(--accent-color); top: -4px; left: 0; animation: slide 3s linear infinite; }
        @keyframes slide { from{left:0%} to{left:calc(100% - 10px)}}
        .strategy-card.active .viz-line::after { animation-duration: 1s; }
    </style>
</head>
<body>
    <div id="toolkit-container"></div>
    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');

        const container = document.getElementById('toolkit-container');
        const strategies = [
            {
                title: 'Selective Filtering',
                analogy: 'Like using noise-canceling headphones in a loud room.',
                explanation: 'Sparse Attention mechanisms reduce cognitive load by forcing the model to only focus on a small, relevant subset of all available information (tokens).',
                vizType: 'dots'
            },
            {
                title: 'Hyper-Efficient Processing',
                analogy: 'Like having a perfectly organized mental workspace.',
                explanation: 'Hardware-aware methods like FlashAttention optimize the raw speed of the attention calculation, reducing memory I/O without changing the logic.',
                vizType: 'line'
            },
            {
                title: 'Building on Past Insights',
                analogy: "Like keeping a journal instead of starting from scratch every day.",
                explanation: 'Recurrence-based approaches (e.g., Transformer-XL) reuse previous calculations, building a chain of memory rather than re-evaluating everything.',
                 vizType: 'dots'
            },
            {
                title: 'Chunking & Prioritizing',
                analogy: 'Like using a highlighter on the most important instructions.',
                explanation: 'Techniques like RAG or Prompt Anchoring pre-filter context or force the model to consistently refer back to the most critical information.',
                vizType: 'line'
            }
        ];

        strategies.forEach(s => {
            const card = document.createElement('div');
            card.className = 'strategy-card';
            card.innerHTML = `
                <div class="card-header">
                    <div class="card-title">${s.title}</div>
                    <div class="card-analogy">${s.analogy}</div>
                </div>
                <div class="card-visualization" id="viz-${s.title.replace(' ', '')}"></div>
                <div class="card-explanation">${s.explanation}</div>
            `;
            container.appendChild(card);
            
            const vizContainer = document.getElementById(`viz-${s.title.replace(' ', '')}`);
            if (s.vizType === 'dots') {
                const viz = document.createElement('div');
                viz.className = 'viz-dots';
                for(let i=0; i<50; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    if (Math.random() < 0.2) dot.classList.add('relevant');
                    viz.appendChild(dot);
                }
                vizContainer.appendChild(viz);
            } else {
                 const viz = document.createElement('div');
                 viz.className = 'viz-line';
                 vizContainer.appendChild(viz);
            }

            card.addEventListener('click', () => {
                document.querySelectorAll('.strategy-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
            });
        });
    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/7/index.html ---
üêï --- DOGS_START_FILE: public/components/4/8/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clearing Skies: Charting the Future of Focused AI</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg: #1a202c;
            --text-color: #a0aec0;
            --node-bg: #2d3748;
            --node-border: #4a5568;
            --center-node-bg: #f59e0b;
            --center-node-text: #1a202c;
            --line-color: #4a5568;
            --highlight-color: #f59e0b;
        }
        body.light-mode {
            --bg: #edf2f7;
            --text-color: #4a5568;
            --node-bg: #ffffff;
            --node-border: #e2e8f0;
            --center-node-bg: #dd6b20;
            --center-node-text: #ffffff;
            --line-color: #cbd5e0;
            --highlight-color: #dd6b20;
        }
        body {
            margin: 0;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg);
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        #mindmap-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        .node {
            position: absolute;
            background-color: var(--node-bg);
            border: 1px solid var(--node-border);
            border-radius: 9999px;
            padding: 8px 15px;
            font-size: clamp(10px, 2vmin, 14px);
            cursor: pointer;
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }
        .node.center {
            font-weight: bold;
            background-color: var(--center-node-bg);
            color: var(--center-node-text);
            font-size: clamp(12px, 2.5vmin, 16px);
            z-index: 10;
        }
        .node.leaf { font-style: italic; }
        .node.expanded {
            border-color: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }
        .sub-node { display: none; }
        .node.expanded + .sub-nodes .sub-node { display: block; }
        .line {
            position: absolute;
            background-color: var(--line-color);
            height: 1px;
            transform-origin: 0 0;
            z-index: -1;
        }
    </style>
</head>
<body>
    <div id="mindmap-container"></div>
    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');

        const container = document.getElementById('mindmap-container');
        const mindmapData = {
            id: 'center', text: 'Future of LLM Attention', children: [
                { id: 'scalable', text: 'Scalable Attention', children: [
                    { id: 'trillion', text: 'Beyond Trillion Tokens' },
                    { id: 'adaptive', text: 'Adaptive Sparsity' }
                ]},
                { id: 'dynamic', text: 'Dynamic Allocation', children: [
                    { id: 'context-aware', text: 'Context-Aware Processing' },
                    { id: 'predictive', text: 'Predictive Focus' }
                ]},
                { id: 'codesign', text: 'Hardware/Software Co-Design', children: [
                    { id: 'pim', text: 'Processing-in-Memory' },
                    { id: 'accelerators', text: 'Specialized Accelerators' }
                ]},
                { id: 'diagnostics', text: 'Advanced Diagnostics', children: [
                    { id: 'benchmarks', text: 'Thrashing Benchmarks' },
                    { id: 'metrics', text: 'Focus Stability Metrics' }
                ]},
                { id: 'cognitive', text: 'Human-AI Symbiosis', children: [
                     { id: 'exec-func', text: 'Executive Function Models' },
                     { id: 'adhd-insights', text: 'Learning from ADHD' }
                ]}
            ]
        };

        function createNode(data, isSubNode = false) {
            const node = document.createElement('div');
            node.id = data.id;
            node.textContent = data.text;
            node.className = 'node' + (isSubNode ? ' sub-node' : '') + (!data.children ? ' leaf' : '');
            if (!isSubNode && data.id === 'center') node.classList.add('center');

            if (data.children) {
                node.addEventListener('click', (e) => {
                    e.stopPropagation();
                    node.classList.toggle('expanded');
                });

                const subNodesContainer = document.createElement('div');
                subNodesContainer.className = 'sub-nodes';
                data.children.forEach(child => {
                    subNodesContainer.appendChild(createNode(child, true));
                });
                container.appendChild(node);
                container.appendChild(subNodesContainer);
            } else {
                 container.appendChild(node);
            }
            return node;
        }

        function drawLine(from, to) {
             const line = document.createElement('div');
             line.className = 'line';
             const fromRect = from.getBoundingClientRect();
             const toRect = to.getBoundingClientRect();
             const containerRect = container.getBoundingClientRect();
             
             const p1 = {x: fromRect.left + fromRect.width/2 - containerRect.left, y: fromRect.top + fromRect.height/2 - containerRect.top};
             const p2 = {x: toRect.left + toRect.width/2 - containerRect.left, y: toRect.top + toRect.height/2 - containerRect.top};
             
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const distance = Math.sqrt(dx*dx + dy*dy);
             const angle = Math.atan2(dy, dx) * 180 / Math.PI;

             line.style.width = `${distance}px`;
             line.style.left = `${p1.x}px`;
             line.style.top = `${p1.y}px`;
             line.style.transform = `rotate(${angle}deg)`;
             container.appendChild(line);
        }

        function layout() {
            container.innerHTML = '';
            createNode(mindmapData);

            const centerEl = document.getElementById('center');
            const w = container.clientWidth;
            const h = container.clientHeight;
            centerEl.style.left = `${w/2}px`;
            centerEl.style.top = `${h/2}px`;

            const mainBranches = document.querySelectorAll('.node:not(.sub-node):not(.center)');
            const angleStep = 360 / mainBranches.length;
            const radius = Math.min(w, h) * 0.35;

            mainBranches.forEach((branch, i) => {
                const angle = (i * angleStep) * Math.PI / 180;
                branch.style.left = `${w/2 + radius * Math.cos(angle)}px`;
                branch.style.top = `${h/2 + radius * Math.sin(angle)}px`;
                drawLine(centerEl, branch);

                const subNodes = branch.nextElementSibling.querySelectorAll('.sub-node');
                const subAngleStep = 40 / (subNodes.length > 1 ? subNodes.length - 1 : 1);
                const subRadius = Math.min(w, h) * 0.15;
                
                subNodes.forEach((sub, j) => {
                    const baseAngle = i * angleStep;
                    const subAngle = (baseAngle - 20 + j * subAngleStep) * Math.PI / 180;
                    
                    const subX = w/2 + (radius + subRadius) * Math.cos(subAngle);
                    const subY = h/2 + (radius + subRadius) * Math.sin(subAngle);

                    sub.style.left = `${subX}px`;
                    sub.style.top = `${subY}px`;
                    drawLine(branch, sub);
                });
            });
        }

        layout();
        window.addEventListener('resize', layout);
    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/8/index.html ---
üêï --- DOGS_START_FILE: public/components/4/9/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navigating the Gale: An Interactive Glossary of Attentional Turmoil</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg: #0f172a;
            --text-color: #94a3b8;
            --term-bg: #1e293b;
            --term-border: #334155;
            --term-hover-border: #f59e0b;
            --panel-bg: #334155;
            --panel-border: #475569;
        }
        body.light-mode {
            --bg: #f1f5f9;
            --text-color: #334155;
            --term-bg: #ffffff;
            --term-border: #e2e8f0;
            --term-hover-border: #d97706;
            --panel-bg: #ffffff;
            --panel-border: #cbd5e1;
        }
        body {
            font-family: sans-serif;
            background-color: var(--bg);
            color: var(--text-color);
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }
        #term-cloud {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .term {
            position: absolute;
            background-color: var(--term-bg);
            border: 1px solid var(--term-border);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: clamp(12px, 2vmin, 18px);
            cursor: pointer;
            transition: all 0.3s ease;
            animation: drift 20s infinite alternate ease-in-out;
        }
        .term:hover {
            border-color: var(--term-hover-border);
            color: var(--term-hover-border);
            transform: scale(1.1);
        }
        @keyframes drift {
            from { transform: translate(0, 0) rotate(-2deg); }
            to { transform: translate(10px, 5px) rotate(2deg); }
        }
        #definition-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            width: 80%;
            max-width: 500px;
            background-color: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 100;
        }
        #definition-panel.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }
        #definition-title {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--term-hover-border);
            margin: 0 0 10px 0;
        }
        #definition-text {
            font-size: 1em;
            line-height: 1.6;
        }
        #close-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-color);
            cursor: pointer;
            opacity: 0.7;
        }
        #close-panel:hover { opacity: 1; }
    </style>
</head>
<body>
    <div id="term-cloud"></div>
    <div id="definition-panel">
        <button id="close-panel">&times;</button>
        <h3 id="definition-title"></h3>
        <p id="definition-text"></p>
    </div>
    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');
        
        const cloud = document.getElementById('term-cloud');
        const panel = document.getElementById('definition-panel');
        const titleEl = document.getElementById('definition-title');
        const textEl = document.getElementById('definition-text');
        const closeBtn = document.getElementById('close-panel');

        const terms = {
            'Attention Thrashing': 'A state where the attention mechanism is overwhelmed by long context, leading to inefficient processing, high latency, and poor accuracy.',
            'KV Cache': 'A memory store for Key/Value vectors from previous tokens to speed up autoregressive generation, but it grows linearly with context length.',
            'O(N¬≤) Complexity': 'The quadratic computational cost of standard self-attention, where processing time grows exponentially with sequence length N.',
            'Lost in the Middle': 'A phenomenon where LLMs struggle to retrieve information located in the middle of a long context, favoring the beginning and end.',
            'Attention Dilution': 'When attention focus spreads too thinly across many tokens in a long context, making it hard to identify critical information.',
            'Attention Sink': 'A behavior where specific, often non-semantic, tokens (like the first token) attract a disproportionate amount of attention.'
        };
        
        Object.entries(terms).forEach(([term, def]) => {
            const termEl = document.createElement('div');
            termEl.className = 'term';
            termEl.textContent = term;
            termEl.style.left = `${10 + Math.random() * 70}%`;
            termEl.style.top = `${10 + Math.random() * 70}%`;
            termEl.style.animationDelay = `${Math.random() * -20}s`;
            
            termEl.addEventListener('click', () => {
                titleEl.textContent = term;
                textEl.textContent = def;
                panel.classList.add('visible');
            });
            cloud.appendChild(termEl);
        });
        
        function closePanel() {
            panel.classList.remove('visible');
        }

        closeBtn.addEventListener('click', closePanel);
        cloud.addEventListener('click', (e) => {
             if (e.target === cloud) closePanel();
        });
    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/9/index.html ---
üêï --- DOGS_START_FILE: public/components/4/10/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Tempest Tamed: A Vision of Future Focused AI</title>
    <!-- CONFIRMATION: No external JS libraries for the visualization are used. -->
    <style>
        :root {
            --bg: #111;
            --text-color: #eee;
            --orb-color: #9333ea;
            --orb-calm-color: #22d3ee;
            --storm-color: #7f1d1d;
            --calm-color: #0d9488;
        }
        body.light-mode {
            --bg: #fdfdfd;
            --text-color: #111;
            --orb-color: #7e22ce;
            --orb-calm-color: #0891b2;
            --storm-color: #b91c1c;
            --calm-color: #0d9488;
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: var(--bg);
            color: var(--text-color);
            transition: background-color 1s ease;
        }
        #scene-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: var(--text-color);
            border-radius: 50%;
            opacity: 0.5;
        }
        #focus-orb {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: var(--orb-color);
            box-shadow: 0 0 20px 5px var(--orb-color);
            transition: all 1s ease-in-out;
            position: relative;
            z-index: 10;
        }
        #focus-orb.calm {
            background-color: var(--orb-calm-color);
            box-shadow: 0 0 30px 10px var(--orb-calm-color);
            transform: scale(1.2);
        }
        #controls {
            position: absolute;
            bottom: 30px;
            z-index: 20;
        }
        button {
            padding: 12px 24px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 8px;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button.storm-button {
            background-color: var(--storm-color);
            border-color: #fca5a5;
            color: #fca5a5;
        }
        button.calm-button {
            background-color: var(--calm-color);
            border-color: #6ee7b7;
            color: #6ee7b7;
        }
        #status-text {
            position: absolute;
            top: 30px;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
            opacity: 0;
            transition: opacity 1s ease;
        }
        #status-text.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="scene-container">
        <div id="focus-orb"></div>
        <div id="status-text"></div>
    </div>
    <div id="controls">
        <button id="toggle-button" class="storm-button">Calm the Storm</button>
    </div>

    <script>
        const theme = new URLSearchParams(window.location.search).get('theme') || 'dark';
        document.body.classList.add(theme === 'light' ? 'light-mode' : 'dark-mode');

        const container = document.getElementById('scene-container');
        const orb = document.getElementById('focus-orb');
        const toggleBtn = document.getElementById('toggle-button');
        const statusText = document.getElementById('status-text');

        let particles = [];
        let isStormy = true;

        function createParticle(isStormy) {
            const p = document.createElement('div');
            p.className = 'particle';
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * Math.min(window.innerWidth, window.innerHeight) * 0.6;
            
            p.style.left = `${window.innerWidth / 2 + Math.cos(angle) * radius}px`;
            p.style.top = `${window.innerHeight / 2 + Math.sin(angle) * radius}px`;

            const duration = isStormy ? Math.random() * 2 + 1 : Math.random() * 10 + 10;
            const animationName = isStormy ? 'storm-swirl' : 'calm-drift';

            const dynamicStyle = document.createElement('style');
            const keyframeName = `anim_${Date.now()}_${Math.random()}`.replace('.', '');
            dynamicStyle.innerHTML = `
                @keyframes ${keyframeName} {
                    0% { transform: translate(0, 0) scale(1); opacity: 0.5; }
                    50% { opacity: 1; }
                    100% {
                        transform: translate(${(Math.random() - 0.5) * 400}px, ${(Math.random() - 0.5) * 400}px) scale(0);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(dynamicStyle);
            p.style.animation = `${keyframeName} ${duration}s linear forwards`;
            
            p.addEventListener('animationend', () => {
                p.remove();
                dynamicStyle.remove();
                if (document.querySelectorAll('.particle').length < (isStormy ? 150 : 30)) {
                    container.appendChild(createParticle(isStormy));
                }
            });

            return p;
        }

        function setScene(storm) {
            isStormy = storm;
            document.querySelectorAll('.particle').forEach(p => p.remove());

            orb.classList.toggle('calm', !isStormy);
            toggleBtn.textContent = isStormy ? 'Calm the Storm' : 'Unleash Tempest';
            toggleBtn.className = isStormy ? 'storm-button' : 'calm-button';

            statusText.textContent = isStormy ? 'Inner Tempest: High Cognitive Load' : 'Sustained Clarity: Efficient Processing';
            statusText.style.color = isStormy ? 'var(--storm-color)' : 'var(--calm-color)';

            setTimeout(() => statusText.classList.add('visible'), 500);
            setTimeout(() => statusText.classList.remove('visible'), 3500);
            
            const numParticles = isStormy ? 150 : 30;
            for (let i = 0; i < numParticles; i++) {
                container.insertBefore(createParticle(isStormy), orb);
            }
        }

        toggleBtn.addEventListener('click', () => setScene(!isStormy));
        
        setScene(true); // Initial state
    </script>
</body>
</html>
üêï --- DOGS_END_FILE: public/components/4/10/index.html ---